
/* DEFS: readonly CProxy_Main mainProxy;
 */
extern CProxy_Main mainProxy;
#ifndef CK_TEMPLATES_ONLY
extern "C" void __xlater_roPup_mainProxy(void *_impl_pup_er) {
  PUP::er &_impl_p=*(PUP::er *)_impl_pup_er;
  _impl_p|mainProxy;
}
#endif /* CK_TEMPLATES_ONLY */

/* DEFS: readonly int elemDimX;
 */
extern int elemDimX;
#ifndef CK_TEMPLATES_ONLY
extern "C" void __xlater_roPup_elemDimX(void *_impl_pup_er) {
  PUP::er &_impl_p=*(PUP::er *)_impl_pup_er;
  _impl_p|elemDimX;
}
#endif /* CK_TEMPLATES_ONLY */

/* DEFS: readonly int elemDimY;
 */
extern int elemDimY;
#ifndef CK_TEMPLATES_ONLY
extern "C" void __xlater_roPup_elemDimY(void *_impl_pup_er) {
  PUP::er &_impl_p=*(PUP::er *)_impl_pup_er;
  _impl_p|elemDimY;
}
#endif /* CK_TEMPLATES_ONLY */

/* DEFS: readonly int elemDimZ;
 */
extern int elemDimZ;
#ifndef CK_TEMPLATES_ONLY
extern "C" void __xlater_roPup_elemDimZ(void *_impl_pup_er) {
  PUP::er &_impl_p=*(PUP::er *)_impl_pup_er;
  _impl_p|elemDimZ;
}
#endif /* CK_TEMPLATES_ONLY */

/* DEFS: readonly int blockDimX;
 */
extern int blockDimX;
#ifndef CK_TEMPLATES_ONLY
extern "C" void __xlater_roPup_blockDimX(void *_impl_pup_er) {
  PUP::er &_impl_p=*(PUP::er *)_impl_pup_er;
  _impl_p|blockDimX;
}
#endif /* CK_TEMPLATES_ONLY */

/* DEFS: readonly int blockDimY;
 */
extern int blockDimY;
#ifndef CK_TEMPLATES_ONLY
extern "C" void __xlater_roPup_blockDimY(void *_impl_pup_er) {
  PUP::er &_impl_p=*(PUP::er *)_impl_pup_er;
  _impl_p|blockDimY;
}
#endif /* CK_TEMPLATES_ONLY */

/* DEFS: readonly int blockDimZ;
 */
extern int blockDimZ;
#ifndef CK_TEMPLATES_ONLY
extern "C" void __xlater_roPup_blockDimZ(void *_impl_pup_er) {
  PUP::er &_impl_p=*(PUP::er *)_impl_pup_er;
  _impl_p|blockDimZ;
}
#endif /* CK_TEMPLATES_ONLY */

/* DEFS: readonly int ghostDimX;
 */
extern int ghostDimX;
#ifndef CK_TEMPLATES_ONLY
extern "C" void __xlater_roPup_ghostDimX(void *_impl_pup_er) {
  PUP::er &_impl_p=*(PUP::er *)_impl_pup_er;
  _impl_p|ghostDimX;
}
#endif /* CK_TEMPLATES_ONLY */

/* DEFS: readonly int ghostDimY;
 */
extern int ghostDimY;
#ifndef CK_TEMPLATES_ONLY
extern "C" void __xlater_roPup_ghostDimY(void *_impl_pup_er) {
  PUP::er &_impl_p=*(PUP::er *)_impl_pup_er;
  _impl_p|ghostDimY;
}
#endif /* CK_TEMPLATES_ONLY */

/* DEFS: readonly int ghostDimZ;
 */
extern int ghostDimZ;
#ifndef CK_TEMPLATES_ONLY
extern "C" void __xlater_roPup_ghostDimZ(void *_impl_pup_er) {
  PUP::er &_impl_p=*(PUP::er *)_impl_pup_er;
  _impl_p|ghostDimZ;
}
#endif /* CK_TEMPLATES_ONLY */

/* DEFS: readonly int chareDimX;
 */
extern int chareDimX;
#ifndef CK_TEMPLATES_ONLY
extern "C" void __xlater_roPup_chareDimX(void *_impl_pup_er) {
  PUP::er &_impl_p=*(PUP::er *)_impl_pup_er;
  _impl_p|chareDimX;
}
#endif /* CK_TEMPLATES_ONLY */

/* DEFS: readonly int chareDimY;
 */
extern int chareDimY;
#ifndef CK_TEMPLATES_ONLY
extern "C" void __xlater_roPup_chareDimY(void *_impl_pup_er) {
  PUP::er &_impl_p=*(PUP::er *)_impl_pup_er;
  _impl_p|chareDimY;
}
#endif /* CK_TEMPLATES_ONLY */

/* DEFS: readonly int chareDimZ;
 */
extern int chareDimZ;
#ifndef CK_TEMPLATES_ONLY
extern "C" void __xlater_roPup_chareDimZ(void *_impl_pup_er) {
  PUP::er &_impl_p=*(PUP::er *)_impl_pup_er;
  _impl_p|chareDimZ;
}
#endif /* CK_TEMPLATES_ONLY */

/* DEFS: readonly double charesPerPE;
 */
extern double charesPerPE;
#ifndef CK_TEMPLATES_ONLY
extern "C" void __xlater_roPup_charesPerPE(void *_impl_pup_er) {
  PUP::er &_impl_p=*(PUP::er *)_impl_pup_er;
  _impl_p|charesPerPE;
}
#endif /* CK_TEMPLATES_ONLY */

/* DEFS: readonly int numElems;
 */
extern int numElems;
#ifndef CK_TEMPLATES_ONLY
extern "C" void __xlater_roPup_numElems(void *_impl_pup_er) {
  PUP::er &_impl_p=*(PUP::er *)_impl_pup_er;
  _impl_p|numElems;
}
#endif /* CK_TEMPLATES_ONLY */

/* DEFS: readonly int numNodes;
 */
extern int numNodes;
#ifndef CK_TEMPLATES_ONLY
extern "C" void __xlater_roPup_numNodes(void *_impl_pup_er) {
  PUP::er &_impl_p=*(PUP::er *)_impl_pup_er;
  _impl_p|numNodes;
}
#endif /* CK_TEMPLATES_ONLY */

/* DEFS: readonly int ghostElems;
 */
extern int ghostElems;
#ifndef CK_TEMPLATES_ONLY
extern "C" void __xlater_roPup_ghostElems(void *_impl_pup_er) {
  PUP::er &_impl_p=*(PUP::er *)_impl_pup_er;
  _impl_p|ghostElems;
}
#endif /* CK_TEMPLATES_ONLY */

/* DEFS: readonly int frontOffset;
 */
extern int frontOffset;
#ifndef CK_TEMPLATES_ONLY
extern "C" void __xlater_roPup_frontOffset(void *_impl_pup_er) {
  PUP::er &_impl_p=*(PUP::er *)_impl_pup_er;
  _impl_p|frontOffset;
}
#endif /* CK_TEMPLATES_ONLY */

/* DEFS: readonly int backOffset;
 */
extern int backOffset;
#ifndef CK_TEMPLATES_ONLY
extern "C" void __xlater_roPup_backOffset(void *_impl_pup_er) {
  PUP::er &_impl_p=*(PUP::er *)_impl_pup_er;
  _impl_p|backOffset;
}
#endif /* CK_TEMPLATES_ONLY */

/* DEFS: readonly int rightOffset;
 */
extern int rightOffset;
#ifndef CK_TEMPLATES_ONLY
extern "C" void __xlater_roPup_rightOffset(void *_impl_pup_er) {
  PUP::er &_impl_p=*(PUP::er *)_impl_pup_er;
  _impl_p|rightOffset;
}
#endif /* CK_TEMPLATES_ONLY */

/* DEFS: readonly int leftOffset;
 */
extern int leftOffset;
#ifndef CK_TEMPLATES_ONLY
extern "C" void __xlater_roPup_leftOffset(void *_impl_pup_er) {
  PUP::er &_impl_p=*(PUP::er *)_impl_pup_er;
  _impl_p|leftOffset;
}
#endif /* CK_TEMPLATES_ONLY */

/* DEFS: readonly int upOffset;
 */
extern int upOffset;
#ifndef CK_TEMPLATES_ONLY
extern "C" void __xlater_roPup_upOffset(void *_impl_pup_er) {
  PUP::er &_impl_p=*(PUP::er *)_impl_pup_er;
  _impl_p|upOffset;
}
#endif /* CK_TEMPLATES_ONLY */

/* DEFS: readonly int downOffset;
 */
extern int downOffset;
#ifndef CK_TEMPLATES_ONLY
extern "C" void __xlater_roPup_downOffset(void *_impl_pup_er) {
  PUP::er &_impl_p=*(PUP::er *)_impl_pup_er;
  _impl_p|downOffset;
}
#endif /* CK_TEMPLATES_ONLY */

/* DEFS: readonly Real_t stopTime;
 */
extern Real_t stopTime;
#ifndef CK_TEMPLATES_ONLY
extern "C" void __xlater_roPup_stopTime(void *_impl_pup_er) {
  PUP::er &_impl_p=*(PUP::er *)_impl_pup_er;
  _impl_p|stopTime;
}
#endif /* CK_TEMPLATES_ONLY */

/* DEFS: readonly int lbFrequency;
 */
extern int lbFrequency;
#ifndef CK_TEMPLATES_ONLY
extern "C" void __xlater_roPup_lbFrequency(void *_impl_pup_er) {
  PUP::er &_impl_p=*(PUP::er *)_impl_pup_er;
  _impl_p|lbFrequency;
}
#endif /* CK_TEMPLATES_ONLY */

/* DEFS: readonly int cpFrequency;
 */
extern int cpFrequency;
#ifndef CK_TEMPLATES_ONLY
extern "C" void __xlater_roPup_cpFrequency(void *_impl_pup_er) {
  PUP::er &_impl_p=*(PUP::er *)_impl_pup_er;
  _impl_p|cpFrequency;
}
#endif /* CK_TEMPLATES_ONLY */

/* DEFS: readonly int maxIterations;
 */
extern int maxIterations;
#ifndef CK_TEMPLATES_ONLY
extern "C" void __xlater_roPup_maxIterations(void *_impl_pup_er) {
  PUP::er &_impl_p=*(PUP::er *)_impl_pup_er;
  _impl_p|maxIterations;
}
#endif /* CK_TEMPLATES_ONLY */



/* DEFS: mainchare Main: Chare{
Main(CkArgMsg* impl_msg);
void averageTimeCheckin(CkReductionMsg* impl_msg);
void initCheckin(CkReductionMsg* impl_msg);
void report(CkReductionMsg* impl_msg);
void afterCkpt(void);
void updateLastT(void);
Main(CkMigrateMessage* impl_msg);
};
 */
#ifndef CK_TEMPLATES_ONLY
 int CkIndex_Main::__idx=0;
#endif /* CK_TEMPLATES_ONLY */
#ifndef CK_TEMPLATES_ONLY
/* DEFS: Main(CkArgMsg* impl_msg);
 */

CkChareID CProxy_Main::ckNew(CkArgMsg* impl_msg, int impl_onPE)
{
  CkChareID impl_ret;
  CkCreateChare(CkIndex_Main::__idx, CkIndex_Main::idx_Main_CkArgMsg(), impl_msg, &impl_ret, impl_onPE);
  return impl_ret;
}

void CProxy_Main::ckNew(CkArgMsg* impl_msg, CkChareID* pcid, int impl_onPE)
{
  CkCreateChare(CkIndex_Main::__idx, CkIndex_Main::idx_Main_CkArgMsg(), impl_msg, pcid, impl_onPE);
}

  CProxy_Main::CProxy_Main(CkArgMsg* impl_msg, int impl_onPE)
{
  CkChareID impl_ret;
  CkCreateChare(CkIndex_Main::__idx, CkIndex_Main::idx_Main_CkArgMsg(), impl_msg, &impl_ret, impl_onPE);
  ckSetChareID(impl_ret);
}

// Entry point registration function

int CkIndex_Main::reg_Main_CkArgMsg() {
  int epidx = CkRegisterEp("Main(CkArgMsg* impl_msg)",
      _call_Main_CkArgMsg, CMessage_CkArgMsg::__idx, __idx, 0);
  CkRegisterMessagePupFn(epidx, (CkMessagePupFn)CkArgMsg::ckDebugPup);
  return epidx;
}


void CkIndex_Main::_call_Main_CkArgMsg(void* impl_msg, void* impl_obj_void)
{
  Main* impl_obj = static_cast<Main *>(impl_obj_void);
  new (impl_obj) Main((CkArgMsg*)impl_msg);
}
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: void averageTimeCheckin(CkReductionMsg* impl_msg);
 */

void CProxy_Main::averageTimeCheckin(CkReductionMsg* impl_msg)
{
  ckCheck();
  if (ckIsDelegated()) {
    int destPE=CkChareMsgPrep(CkIndex_Main::idx_averageTimeCheckin_CkReductionMsg(), impl_msg, &ckGetChareID());
    if (destPE!=-1) ckDelegatedTo()->ChareSend(ckDelegatedPtr(),CkIndex_Main::idx_averageTimeCheckin_CkReductionMsg(), impl_msg, &ckGetChareID(),destPE);
  }
  else CkSendMsg(CkIndex_Main::idx_averageTimeCheckin_CkReductionMsg(), impl_msg, &ckGetChareID(),0);
}

// Entry point registration function

int CkIndex_Main::reg_averageTimeCheckin_CkReductionMsg() {
  int epidx = CkRegisterEp("averageTimeCheckin(CkReductionMsg* impl_msg)",
      _call_averageTimeCheckin_CkReductionMsg, CMessage_CkReductionMsg::__idx, __idx, 0);
  CkRegisterMessagePupFn(epidx, (CkMessagePupFn)CkReductionMsg::ckDebugPup);
  return epidx;
}


void CkIndex_Main::_call_averageTimeCheckin_CkReductionMsg(void* impl_msg, void* impl_obj_void)
{
  Main* impl_obj = static_cast<Main *>(impl_obj_void);
  impl_obj->averageTimeCheckin((CkReductionMsg*)impl_msg);
}
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: void initCheckin(CkReductionMsg* impl_msg);
 */

void CProxy_Main::initCheckin(CkReductionMsg* impl_msg)
{
  ckCheck();
  if (ckIsDelegated()) {
    int destPE=CkChareMsgPrep(CkIndex_Main::idx_initCheckin_CkReductionMsg(), impl_msg, &ckGetChareID());
    if (destPE!=-1) ckDelegatedTo()->ChareSend(ckDelegatedPtr(),CkIndex_Main::idx_initCheckin_CkReductionMsg(), impl_msg, &ckGetChareID(),destPE);
  }
  else CkSendMsg(CkIndex_Main::idx_initCheckin_CkReductionMsg(), impl_msg, &ckGetChareID(),0);
}

// Entry point registration function

int CkIndex_Main::reg_initCheckin_CkReductionMsg() {
  int epidx = CkRegisterEp("initCheckin(CkReductionMsg* impl_msg)",
      _call_initCheckin_CkReductionMsg, CMessage_CkReductionMsg::__idx, __idx, 0);
  CkRegisterMessagePupFn(epidx, (CkMessagePupFn)CkReductionMsg::ckDebugPup);
  return epidx;
}


void CkIndex_Main::_call_initCheckin_CkReductionMsg(void* impl_msg, void* impl_obj_void)
{
  Main* impl_obj = static_cast<Main *>(impl_obj_void);
  impl_obj->initCheckin((CkReductionMsg*)impl_msg);
}
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: void report(CkReductionMsg* impl_msg);
 */

void CProxy_Main::report(CkReductionMsg* impl_msg)
{
  ckCheck();
  if (ckIsDelegated()) {
    int destPE=CkChareMsgPrep(CkIndex_Main::idx_report_CkReductionMsg(), impl_msg, &ckGetChareID());
    if (destPE!=-1) ckDelegatedTo()->ChareSend(ckDelegatedPtr(),CkIndex_Main::idx_report_CkReductionMsg(), impl_msg, &ckGetChareID(),destPE);
  }
  else CkSendMsg(CkIndex_Main::idx_report_CkReductionMsg(), impl_msg, &ckGetChareID(),0);
}

// Entry point registration function

int CkIndex_Main::reg_report_CkReductionMsg() {
  int epidx = CkRegisterEp("report(CkReductionMsg* impl_msg)",
      _call_report_CkReductionMsg, CMessage_CkReductionMsg::__idx, __idx, 0);
  CkRegisterMessagePupFn(epidx, (CkMessagePupFn)CkReductionMsg::ckDebugPup);
  return epidx;
}


void CkIndex_Main::_call_report_CkReductionMsg(void* impl_msg, void* impl_obj_void)
{
  Main* impl_obj = static_cast<Main *>(impl_obj_void);
  impl_obj->report((CkReductionMsg*)impl_msg);
}
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: void afterCkpt(void);
 */

void CProxy_Main::afterCkpt(void)
{
  ckCheck();
  void *impl_msg = CkAllocSysMsg();
  if (ckIsDelegated()) {
    int destPE=CkChareMsgPrep(CkIndex_Main::idx_afterCkpt_void(), impl_msg, &ckGetChareID());
    if (destPE!=-1) ckDelegatedTo()->ChareSend(ckDelegatedPtr(),CkIndex_Main::idx_afterCkpt_void(), impl_msg, &ckGetChareID(),destPE);
  }
  else CkSendMsg(CkIndex_Main::idx_afterCkpt_void(), impl_msg, &ckGetChareID(),0);
}

// Entry point registration function

int CkIndex_Main::reg_afterCkpt_void() {
  int epidx = CkRegisterEp("afterCkpt(void)",
      _call_afterCkpt_void, 0, __idx, 0);
  return epidx;
}


void CkIndex_Main::_call_afterCkpt_void(void* impl_msg, void* impl_obj_void)
{
  Main* impl_obj = static_cast<Main *>(impl_obj_void);
  CkFreeSysMsg(impl_msg);
  impl_obj->afterCkpt();
}
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: void updateLastT(void);
 */

void CProxy_Main::updateLastT(void)
{
  ckCheck();
  void *impl_msg = CkAllocSysMsg();
  if (ckIsDelegated()) {
    int destPE=CkChareMsgPrep(CkIndex_Main::idx_updateLastT_void(), impl_msg, &ckGetChareID());
    if (destPE!=-1) ckDelegatedTo()->ChareSend(ckDelegatedPtr(),CkIndex_Main::idx_updateLastT_void(), impl_msg, &ckGetChareID(),destPE);
  }
  else CkSendMsg(CkIndex_Main::idx_updateLastT_void(), impl_msg, &ckGetChareID(),0);
}

// Entry point registration function

int CkIndex_Main::reg_updateLastT_void() {
  int epidx = CkRegisterEp("updateLastT(void)",
      _call_updateLastT_void, 0, __idx, 0);
  return epidx;
}


void CkIndex_Main::_call_updateLastT_void(void* impl_msg, void* impl_obj_void)
{
  Main* impl_obj = static_cast<Main *>(impl_obj_void);
  CkFreeSysMsg(impl_msg);
  impl_obj->updateLastT();
}
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: Main(CkMigrateMessage* impl_msg);
 */

// Entry point registration function

int CkIndex_Main::reg_Main_CkMigrateMessage() {
  int epidx = CkRegisterEp("Main(CkMigrateMessage* impl_msg)",
      _call_Main_CkMigrateMessage, 0, __idx, 0);
  return epidx;
}


void CkIndex_Main::_call_Main_CkMigrateMessage(void* impl_msg, void* impl_obj_void)
{
  Main* impl_obj = static_cast<Main *>(impl_obj_void);
  new (impl_obj) Main((CkMigrateMessage*)impl_msg);
}
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
#endif /* CK_TEMPLATES_ONLY */
#ifndef CK_TEMPLATES_ONLY
void CkIndex_Main::__register(const char *s, size_t size) {
  __idx = CkRegisterChare(s, size, TypeMainChare);
  CkRegisterBase(__idx, CkIndex_Chare::__idx);
  // REG: Main(CkArgMsg* impl_msg);
  idx_Main_CkArgMsg();
  CkRegisterMainChare(__idx, idx_Main_CkArgMsg());

  // REG: void averageTimeCheckin(CkReductionMsg* impl_msg);
  idx_averageTimeCheckin_CkReductionMsg();

  // REG: void initCheckin(CkReductionMsg* impl_msg);
  idx_initCheckin_CkReductionMsg();

  // REG: void report(CkReductionMsg* impl_msg);
  idx_report_CkReductionMsg();

  // REG: void afterCkpt(void);
  idx_afterCkpt_void();

  // REG: void updateLastT(void);
  idx_updateLastT_void();

  // REG: Main(CkMigrateMessage* impl_msg);
  idx_Main_CkMigrateMessage();
  CkRegisterMigCtor(__idx, idx_Main_CkMigrateMessage());

}
#endif /* CK_TEMPLATES_ONLY */

/* DEFS: array Domain: ArrayElement{
Domain(void);
void startLB(void);
void beginIteration(void);
void resumeNodeIteration(void);
void resumeElemIteration(void);
void sendNodalMass(void);
void ResumeFromSync(void);
void receiveNodeGhosts(int iter, int dir, int width, int height, const Real_t *ghostData);
void receiveElemGhosts(int iter, int dir, int width, int height, const Real_t *ghostData);
void receiveNodalMass(int dir, int width, int height, const Real_t *ghostData);
void printEnergy(void);
void begin_iteration(void);
void doSync(void);
void run1(void);
Domain(CkMigrateMessage* impl_msg);
};
 */
#ifndef CK_TEMPLATES_ONLY
 int CkIndex_Domain::__idx=0;
#endif /* CK_TEMPLATES_ONLY */
#ifndef CK_TEMPLATES_ONLY
/* DEFS: Domain(void);
 */

void CProxyElement_Domain::insert(int onPE)
{ 
  void *impl_msg = CkAllocSysMsg();
   ckInsert((CkArrayMessage *)impl_msg,CkIndex_Domain::idx_Domain_void(),onPE);
}
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: void startLB(void);
 */

void CProxyElement_Domain::startLB(void) 
{
  ckCheck();
  void *impl_msg = CkAllocSysMsg();
  CkArrayMessage *impl_amsg=(CkArrayMessage *)impl_msg;
  impl_amsg->array_setIfNotThere(CkArray_IfNotThere_buffer);
  ckSend(impl_amsg, CkIndex_Domain::idx_startLB_void(),0);
}
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: void beginIteration(void);
 */

void CProxyElement_Domain::beginIteration(void) 
{
  ckCheck();
  void *impl_msg = CkAllocSysMsg();
  CkArrayMessage *impl_amsg=(CkArrayMessage *)impl_msg;
  impl_amsg->array_setIfNotThere(CkArray_IfNotThere_buffer);
  ckSend(impl_amsg, CkIndex_Domain::idx_beginIteration_void(),0);
}
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: void resumeNodeIteration(void);
 */

void CProxyElement_Domain::resumeNodeIteration(void) 
{
  ckCheck();
  void *impl_msg = CkAllocSysMsg();
  CkArrayMessage *impl_amsg=(CkArrayMessage *)impl_msg;
  impl_amsg->array_setIfNotThere(CkArray_IfNotThere_buffer);
  ckSend(impl_amsg, CkIndex_Domain::idx_resumeNodeIteration_void(),0);
}
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: void resumeElemIteration(void);
 */

void CProxyElement_Domain::resumeElemIteration(void) 
{
  ckCheck();
  void *impl_msg = CkAllocSysMsg();
  CkArrayMessage *impl_amsg=(CkArrayMessage *)impl_msg;
  impl_amsg->array_setIfNotThere(CkArray_IfNotThere_buffer);
  ckSend(impl_amsg, CkIndex_Domain::idx_resumeElemIteration_void(),0);
}
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: void sendNodalMass(void);
 */

void CProxyElement_Domain::sendNodalMass(void) 
{
  ckCheck();
  void *impl_msg = CkAllocSysMsg();
  CkArrayMessage *impl_amsg=(CkArrayMessage *)impl_msg;
  impl_amsg->array_setIfNotThere(CkArray_IfNotThere_buffer);
  ckSend(impl_amsg, CkIndex_Domain::idx_sendNodalMass_void(),0);
}
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: void ResumeFromSync(void);
 */

void CProxyElement_Domain::ResumeFromSync(void) 
{
  ckCheck();
  void *impl_msg = CkAllocSysMsg();
  CkArrayMessage *impl_amsg=(CkArrayMessage *)impl_msg;
  impl_amsg->array_setIfNotThere(CkArray_IfNotThere_buffer);
  ckSend(impl_amsg, CkIndex_Domain::idx_ResumeFromSync_void(),0);
}
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: void receiveNodeGhosts(int iter, int dir, int width, int height, const Real_t *ghostData);
 */

void CProxyElement_Domain::receiveNodeGhosts(int iter, int dir, int width, int height, const Real_t *ghostData, const CkEntryOptions *impl_e_opts) 
{
  ckCheck();
  //Marshall: int iter, int dir, int width, int height, const Real_t *ghostData
  int impl_off=0;
  int impl_arrstart=0;
  int impl_off_ghostData, impl_cnt_ghostData;
  impl_off_ghostData=impl_off=CK_ALIGN(impl_off,sizeof(Real_t));
  impl_off+=(impl_cnt_ghostData=sizeof(Real_t)*(width*height*3));
  { //Find the size of the PUP'd data
    PUP::sizer implP;
    implP|iter;
    implP|dir;
    implP|width;
    implP|height;
    implP|impl_off_ghostData;
    implP|impl_cnt_ghostData;
    impl_arrstart=CK_ALIGN(implP.size(),16);
    impl_off+=impl_arrstart;
  }
  CkMarshallMsg *impl_msg=CkAllocateMarshallMsg(impl_off,impl_e_opts);
  { //Copy over the PUP'd data
    PUP::toMem implP((void *)impl_msg->msgBuf);
    implP|iter;
    implP|dir;
    implP|width;
    implP|height;
    implP|impl_off_ghostData;
    implP|impl_cnt_ghostData;
  }
  char *impl_buf=impl_msg->msgBuf+impl_arrstart;
  memcpy(impl_buf+impl_off_ghostData,ghostData,impl_cnt_ghostData);
  CkArrayMessage *impl_amsg=(CkArrayMessage *)impl_msg;
  impl_amsg->array_setIfNotThere(CkArray_IfNotThere_buffer);
  ckSend(impl_amsg, CkIndex_Domain::idx_receiveNodeGhosts_marshall8(),0);
}
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: void receiveElemGhosts(int iter, int dir, int width, int height, const Real_t *ghostData);
 */

void CProxyElement_Domain::receiveElemGhosts(int iter, int dir, int width, int height, const Real_t *ghostData, const CkEntryOptions *impl_e_opts) 
{
  ckCheck();
  //Marshall: int iter, int dir, int width, int height, const Real_t *ghostData
  int impl_off=0;
  int impl_arrstart=0;
  int impl_off_ghostData, impl_cnt_ghostData;
  impl_off_ghostData=impl_off=CK_ALIGN(impl_off,sizeof(Real_t));
  impl_off+=(impl_cnt_ghostData=sizeof(Real_t)*(width*height*3));
  { //Find the size of the PUP'd data
    PUP::sizer implP;
    implP|iter;
    implP|dir;
    implP|width;
    implP|height;
    implP|impl_off_ghostData;
    implP|impl_cnt_ghostData;
    impl_arrstart=CK_ALIGN(implP.size(),16);
    impl_off+=impl_arrstart;
  }
  CkMarshallMsg *impl_msg=CkAllocateMarshallMsg(impl_off,impl_e_opts);
  { //Copy over the PUP'd data
    PUP::toMem implP((void *)impl_msg->msgBuf);
    implP|iter;
    implP|dir;
    implP|width;
    implP|height;
    implP|impl_off_ghostData;
    implP|impl_cnt_ghostData;
  }
  char *impl_buf=impl_msg->msgBuf+impl_arrstart;
  memcpy(impl_buf+impl_off_ghostData,ghostData,impl_cnt_ghostData);
  CkArrayMessage *impl_amsg=(CkArrayMessage *)impl_msg;
  impl_amsg->array_setIfNotThere(CkArray_IfNotThere_buffer);
  ckSend(impl_amsg, CkIndex_Domain::idx_receiveElemGhosts_marshall9(),0);
}
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: void receiveNodalMass(int dir, int width, int height, const Real_t *ghostData);
 */

void CProxyElement_Domain::receiveNodalMass(int dir, int width, int height, const Real_t *ghostData, const CkEntryOptions *impl_e_opts) 
{
  ckCheck();
  //Marshall: int dir, int width, int height, const Real_t *ghostData
  int impl_off=0;
  int impl_arrstart=0;
  int impl_off_ghostData, impl_cnt_ghostData;
  impl_off_ghostData=impl_off=CK_ALIGN(impl_off,sizeof(Real_t));
  impl_off+=(impl_cnt_ghostData=sizeof(Real_t)*(width*height));
  { //Find the size of the PUP'd data
    PUP::sizer implP;
    implP|dir;
    implP|width;
    implP|height;
    implP|impl_off_ghostData;
    implP|impl_cnt_ghostData;
    impl_arrstart=CK_ALIGN(implP.size(),16);
    impl_off+=impl_arrstart;
  }
  CkMarshallMsg *impl_msg=CkAllocateMarshallMsg(impl_off,impl_e_opts);
  { //Copy over the PUP'd data
    PUP::toMem implP((void *)impl_msg->msgBuf);
    implP|dir;
    implP|width;
    implP|height;
    implP|impl_off_ghostData;
    implP|impl_cnt_ghostData;
  }
  char *impl_buf=impl_msg->msgBuf+impl_arrstart;
  memcpy(impl_buf+impl_off_ghostData,ghostData,impl_cnt_ghostData);
  CkArrayMessage *impl_amsg=(CkArrayMessage *)impl_msg;
  impl_amsg->array_setIfNotThere(CkArray_IfNotThere_buffer);
  ckSend(impl_amsg, CkIndex_Domain::idx_receiveNodalMass_marshall10(),0);
}
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: void printEnergy(void);
 */

void CProxyElement_Domain::printEnergy(void) 
{
  ckCheck();
  void *impl_msg = CkAllocSysMsg();
  CkArrayMessage *impl_amsg=(CkArrayMessage *)impl_msg;
  impl_amsg->array_setIfNotThere(CkArray_IfNotThere_buffer);
  ckSend(impl_amsg, CkIndex_Domain::idx_printEnergy_void(),0);
}
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: void begin_iteration(void);
 */

void CProxyElement_Domain::begin_iteration(void) 
{
  ckCheck();
  void *impl_msg = CkAllocSysMsg();
  CkArrayMessage *impl_amsg=(CkArrayMessage *)impl_msg;
  impl_amsg->array_setIfNotThere(CkArray_IfNotThere_buffer);
  ckSend(impl_amsg, CkIndex_Domain::idx_begin_iteration_void(),0);
}
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: void doSync(void);
 */

void CProxyElement_Domain::doSync(void) 
{
  ckCheck();
  void *impl_msg = CkAllocSysMsg();
  CkArrayMessage *impl_amsg=(CkArrayMessage *)impl_msg;
  impl_amsg->array_setIfNotThere(CkArray_IfNotThere_buffer);
  ckSend(impl_amsg, CkIndex_Domain::idx_doSync_void(),0);
}
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: void run1(void);
 */

void CProxyElement_Domain::run1(void) 
{
  ckCheck();
  void *impl_msg = CkAllocSysMsg();
  CkArrayMessage *impl_amsg=(CkArrayMessage *)impl_msg;
  impl_amsg->array_setIfNotThere(CkArray_IfNotThere_buffer);
  ckSend(impl_amsg, CkIndex_Domain::idx_run1_void(),0);
}
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: Domain(CkMigrateMessage* impl_msg);
 */
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: Domain(void);
 */

CkArrayID CProxy_Domain::ckNew(const CkArrayOptions &opts)
{ 
  void *impl_msg = CkAllocSysMsg();
   return ckCreateArray((CkArrayMessage *)impl_msg,CkIndex_Domain::idx_Domain_void(),opts);
}

CkArrayID CProxy_Domain::ckNew(const int s1, const int s2, const int s3)
{ 
  void *impl_msg = CkAllocSysMsg();
   return ckCreateArray((CkArrayMessage *)impl_msg,CkIndex_Domain::idx_Domain_void(),CkArrayOptions(s1, s2, s3));
}

// Entry point registration function

int CkIndex_Domain::reg_Domain_void() {
  int epidx = CkRegisterEp("Domain(void)",
      _call_Domain_void, 0, __idx, 0);
  return epidx;
}


void CkIndex_Domain::_call_Domain_void(void* impl_msg, void* impl_obj_void)
{
  Domain* impl_obj = static_cast<Domain *>(impl_obj_void);
  CkFreeSysMsg(impl_msg);
  new (impl_obj) Domain();
}
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: void startLB(void);
 */

void CProxy_Domain::startLB(void) 
{
  ckCheck();
  void *impl_msg = CkAllocSysMsg();
  CkArrayMessage *impl_amsg=(CkArrayMessage *)impl_msg;
  impl_amsg->array_setIfNotThere(CkArray_IfNotThere_buffer);
  ckBroadcast(impl_amsg, CkIndex_Domain::idx_startLB_void(),0);
}

// Entry point registration function

int CkIndex_Domain::reg_startLB_void() {
  int epidx = CkRegisterEp("startLB(void)",
      _call_startLB_void, 0, __idx, 0);
  return epidx;
}


void CkIndex_Domain::_call_startLB_void(void* impl_msg, void* impl_obj_void)
{
  Domain* impl_obj = static_cast<Domain *>(impl_obj_void);
  CkFreeSysMsg(impl_msg);
  impl_obj->startLB();
}
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: void beginIteration(void);
 */

void CProxy_Domain::beginIteration(void) 
{
  ckCheck();
  void *impl_msg = CkAllocSysMsg();
  CkArrayMessage *impl_amsg=(CkArrayMessage *)impl_msg;
  impl_amsg->array_setIfNotThere(CkArray_IfNotThere_buffer);
  ckBroadcast(impl_amsg, CkIndex_Domain::idx_beginIteration_void(),0);
}

// Entry point registration function

int CkIndex_Domain::reg_beginIteration_void() {
  int epidx = CkRegisterEp("beginIteration(void)",
      _call_beginIteration_void, 0, __idx, 0);
  return epidx;
}


void CkIndex_Domain::_call_beginIteration_void(void* impl_msg, void* impl_obj_void)
{
  Domain* impl_obj = static_cast<Domain *>(impl_obj_void);
  CkFreeSysMsg(impl_msg);
  impl_obj->beginIteration();
}
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: void resumeNodeIteration(void);
 */

void CProxy_Domain::resumeNodeIteration(void) 
{
  ckCheck();
  void *impl_msg = CkAllocSysMsg();
  CkArrayMessage *impl_amsg=(CkArrayMessage *)impl_msg;
  impl_amsg->array_setIfNotThere(CkArray_IfNotThere_buffer);
  ckBroadcast(impl_amsg, CkIndex_Domain::idx_resumeNodeIteration_void(),0);
}

// Entry point registration function

int CkIndex_Domain::reg_resumeNodeIteration_void() {
  int epidx = CkRegisterEp("resumeNodeIteration(void)",
      _call_resumeNodeIteration_void, 0, __idx, 0);
  return epidx;
}


void CkIndex_Domain::_call_resumeNodeIteration_void(void* impl_msg, void* impl_obj_void)
{
  Domain* impl_obj = static_cast<Domain *>(impl_obj_void);
  CkFreeSysMsg(impl_msg);
  impl_obj->resumeNodeIteration();
}
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: void resumeElemIteration(void);
 */

void CProxy_Domain::resumeElemIteration(void) 
{
  ckCheck();
  void *impl_msg = CkAllocSysMsg();
  CkArrayMessage *impl_amsg=(CkArrayMessage *)impl_msg;
  impl_amsg->array_setIfNotThere(CkArray_IfNotThere_buffer);
  ckBroadcast(impl_amsg, CkIndex_Domain::idx_resumeElemIteration_void(),0);
}

// Entry point registration function

int CkIndex_Domain::reg_resumeElemIteration_void() {
  int epidx = CkRegisterEp("resumeElemIteration(void)",
      _call_resumeElemIteration_void, 0, __idx, 0);
  return epidx;
}


void CkIndex_Domain::_call_resumeElemIteration_void(void* impl_msg, void* impl_obj_void)
{
  Domain* impl_obj = static_cast<Domain *>(impl_obj_void);
  CkFreeSysMsg(impl_msg);
  impl_obj->resumeElemIteration();
}
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: void sendNodalMass(void);
 */

void CProxy_Domain::sendNodalMass(void) 
{
  ckCheck();
  void *impl_msg = CkAllocSysMsg();
  CkArrayMessage *impl_amsg=(CkArrayMessage *)impl_msg;
  impl_amsg->array_setIfNotThere(CkArray_IfNotThere_buffer);
  ckBroadcast(impl_amsg, CkIndex_Domain::idx_sendNodalMass_void(),0);
}

// Entry point registration function

int CkIndex_Domain::reg_sendNodalMass_void() {
  int epidx = CkRegisterEp("sendNodalMass(void)",
      _call_sendNodalMass_void, 0, __idx, 0);
  return epidx;
}


void CkIndex_Domain::_call_sendNodalMass_void(void* impl_msg, void* impl_obj_void)
{
  Domain* impl_obj = static_cast<Domain *>(impl_obj_void);
  CkFreeSysMsg(impl_msg);
  impl_obj->sendNodalMass();
}
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: void ResumeFromSync(void);
 */

void CProxy_Domain::ResumeFromSync(void) 
{
  ckCheck();
  void *impl_msg = CkAllocSysMsg();
  CkArrayMessage *impl_amsg=(CkArrayMessage *)impl_msg;
  impl_amsg->array_setIfNotThere(CkArray_IfNotThere_buffer);
  ckBroadcast(impl_amsg, CkIndex_Domain::idx_ResumeFromSync_void(),0);
}

// Entry point registration function

int CkIndex_Domain::reg_ResumeFromSync_void() {
  int epidx = CkRegisterEp("ResumeFromSync(void)",
      _call_ResumeFromSync_void, 0, __idx, 0);
  return epidx;
}


void CkIndex_Domain::_call_ResumeFromSync_void(void* impl_msg, void* impl_obj_void)
{
  Domain* impl_obj = static_cast<Domain *>(impl_obj_void);
  CkFreeSysMsg(impl_msg);
  impl_obj->ResumeFromSync();
}
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: void receiveNodeGhosts(int iter, int dir, int width, int height, const Real_t *ghostData);
 */

void CProxy_Domain::receiveNodeGhosts(int iter, int dir, int width, int height, const Real_t *ghostData, const CkEntryOptions *impl_e_opts) 
{
  ckCheck();
  //Marshall: int iter, int dir, int width, int height, const Real_t *ghostData
  int impl_off=0;
  int impl_arrstart=0;
  int impl_off_ghostData, impl_cnt_ghostData;
  impl_off_ghostData=impl_off=CK_ALIGN(impl_off,sizeof(Real_t));
  impl_off+=(impl_cnt_ghostData=sizeof(Real_t)*(width*height*3));
  { //Find the size of the PUP'd data
    PUP::sizer implP;
    implP|iter;
    implP|dir;
    implP|width;
    implP|height;
    implP|impl_off_ghostData;
    implP|impl_cnt_ghostData;
    impl_arrstart=CK_ALIGN(implP.size(),16);
    impl_off+=impl_arrstart;
  }
  CkMarshallMsg *impl_msg=CkAllocateMarshallMsg(impl_off,impl_e_opts);
  { //Copy over the PUP'd data
    PUP::toMem implP((void *)impl_msg->msgBuf);
    implP|iter;
    implP|dir;
    implP|width;
    implP|height;
    implP|impl_off_ghostData;
    implP|impl_cnt_ghostData;
  }
  char *impl_buf=impl_msg->msgBuf+impl_arrstart;
  memcpy(impl_buf+impl_off_ghostData,ghostData,impl_cnt_ghostData);
  CkArrayMessage *impl_amsg=(CkArrayMessage *)impl_msg;
  impl_amsg->array_setIfNotThere(CkArray_IfNotThere_buffer);
  ckBroadcast(impl_amsg, CkIndex_Domain::idx_receiveNodeGhosts_marshall8(),0);
}

// Entry point registration function

int CkIndex_Domain::reg_receiveNodeGhosts_marshall8() {
  int epidx = CkRegisterEp("receiveNodeGhosts(int iter, int dir, int width, int height, const Real_t *ghostData)",
      _call_receiveNodeGhosts_marshall8, CkMarshallMsg::__idx, __idx, 0+CK_EP_NOKEEP);
  CkRegisterMarshallUnpackFn(epidx, _callmarshall_receiveNodeGhosts_marshall8);
  CkRegisterMessagePupFn(epidx, _marshallmessagepup_receiveNodeGhosts_marshall8);

  return epidx;
}


void CkIndex_Domain::_call_receiveNodeGhosts_marshall8(void* impl_msg, void* impl_obj_void)
{
  Domain* impl_obj = static_cast<Domain *>(impl_obj_void);
  CkMarshallMsg *impl_msg_typed=(CkMarshallMsg *)impl_msg;
  char *impl_buf=impl_msg_typed->msgBuf;
  /*Unmarshall pup'd fields: int iter, int dir, int width, int height, const Real_t *ghostData*/
  PUP::fromMem implP(impl_buf);
  int iter; implP|iter;
  int dir; implP|dir;
  int width; implP|width;
  int height; implP|height;
  int impl_off_ghostData, impl_cnt_ghostData; 
  implP|impl_off_ghostData;
  implP|impl_cnt_ghostData;
  impl_buf+=CK_ALIGN(implP.size(),16);
  /*Unmarshall arrays:*/
  Real_t *ghostData=(Real_t *)(impl_buf+impl_off_ghostData);
  impl_obj->receiveNodeGhosts(iter, dir, width, height, ghostData);
}

int CkIndex_Domain::_callmarshall_receiveNodeGhosts_marshall8(char* impl_buf, void* impl_obj_void) {
  Domain* impl_obj = static_cast< Domain *>(impl_obj_void);
  /*Unmarshall pup'd fields: int iter, int dir, int width, int height, const Real_t *ghostData*/
  PUP::fromMem implP(impl_buf);
  int iter; implP|iter;
  int dir; implP|dir;
  int width; implP|width;
  int height; implP|height;
  int impl_off_ghostData, impl_cnt_ghostData; 
  implP|impl_off_ghostData;
  implP|impl_cnt_ghostData;
  impl_buf+=CK_ALIGN(implP.size(),16);
  /*Unmarshall arrays:*/
  Real_t *ghostData=(Real_t *)(impl_buf+impl_off_ghostData);
  impl_obj->receiveNodeGhosts(iter, dir, width, height, ghostData);
  return implP.size();
}

void CkIndex_Domain::_marshallmessagepup_receiveNodeGhosts_marshall8(PUP::er &implDestP,void *impl_msg) {
  CkMarshallMsg *impl_msg_typed=(CkMarshallMsg *)impl_msg;
  char *impl_buf=impl_msg_typed->msgBuf;
  /*Unmarshall pup'd fields: int iter, int dir, int width, int height, const Real_t *ghostData*/
  PUP::fromMem implP(impl_buf);
  int iter; implP|iter;
  int dir; implP|dir;
  int width; implP|width;
  int height; implP|height;
  int impl_off_ghostData, impl_cnt_ghostData; 
  implP|impl_off_ghostData;
  implP|impl_cnt_ghostData;
  impl_buf+=CK_ALIGN(implP.size(),16);
  /*Unmarshall arrays:*/
  Real_t *ghostData=(Real_t *)(impl_buf+impl_off_ghostData);
  if (implDestP.hasComments()) implDestP.comment("iter");
  implDestP|iter;
  if (implDestP.hasComments()) implDestP.comment("dir");
  implDestP|dir;
  if (implDestP.hasComments()) implDestP.comment("width");
  implDestP|width;
  if (implDestP.hasComments()) implDestP.comment("height");
  implDestP|height;
  if (implDestP.hasComments()) implDestP.comment("ghostData");
  implDestP.synchronize(PUP::sync_begin_array);
  { for (int impl_i=0;impl_i*(sizeof(*ghostData))<impl_cnt_ghostData;impl_i++) { 
      implDestP.synchronize(PUP::sync_item);
      implDestP|ghostData[impl_i];
  } } 
  implDestP.synchronize(PUP::sync_end_array);
}
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: void receiveElemGhosts(int iter, int dir, int width, int height, const Real_t *ghostData);
 */

void CProxy_Domain::receiveElemGhosts(int iter, int dir, int width, int height, const Real_t *ghostData, const CkEntryOptions *impl_e_opts) 
{
  ckCheck();
  //Marshall: int iter, int dir, int width, int height, const Real_t *ghostData
  int impl_off=0;
  int impl_arrstart=0;
  int impl_off_ghostData, impl_cnt_ghostData;
  impl_off_ghostData=impl_off=CK_ALIGN(impl_off,sizeof(Real_t));
  impl_off+=(impl_cnt_ghostData=sizeof(Real_t)*(width*height*3));
  { //Find the size of the PUP'd data
    PUP::sizer implP;
    implP|iter;
    implP|dir;
    implP|width;
    implP|height;
    implP|impl_off_ghostData;
    implP|impl_cnt_ghostData;
    impl_arrstart=CK_ALIGN(implP.size(),16);
    impl_off+=impl_arrstart;
  }
  CkMarshallMsg *impl_msg=CkAllocateMarshallMsg(impl_off,impl_e_opts);
  { //Copy over the PUP'd data
    PUP::toMem implP((void *)impl_msg->msgBuf);
    implP|iter;
    implP|dir;
    implP|width;
    implP|height;
    implP|impl_off_ghostData;
    implP|impl_cnt_ghostData;
  }
  char *impl_buf=impl_msg->msgBuf+impl_arrstart;
  memcpy(impl_buf+impl_off_ghostData,ghostData,impl_cnt_ghostData);
  CkArrayMessage *impl_amsg=(CkArrayMessage *)impl_msg;
  impl_amsg->array_setIfNotThere(CkArray_IfNotThere_buffer);
  ckBroadcast(impl_amsg, CkIndex_Domain::idx_receiveElemGhosts_marshall9(),0);
}

// Entry point registration function

int CkIndex_Domain::reg_receiveElemGhosts_marshall9() {
  int epidx = CkRegisterEp("receiveElemGhosts(int iter, int dir, int width, int height, const Real_t *ghostData)",
      _call_receiveElemGhosts_marshall9, CkMarshallMsg::__idx, __idx, 0+CK_EP_NOKEEP);
  CkRegisterMarshallUnpackFn(epidx, _callmarshall_receiveElemGhosts_marshall9);
  CkRegisterMessagePupFn(epidx, _marshallmessagepup_receiveElemGhosts_marshall9);

  return epidx;
}


void CkIndex_Domain::_call_receiveElemGhosts_marshall9(void* impl_msg, void* impl_obj_void)
{
  Domain* impl_obj = static_cast<Domain *>(impl_obj_void);
  CkMarshallMsg *impl_msg_typed=(CkMarshallMsg *)impl_msg;
  char *impl_buf=impl_msg_typed->msgBuf;
  /*Unmarshall pup'd fields: int iter, int dir, int width, int height, const Real_t *ghostData*/
  PUP::fromMem implP(impl_buf);
  int iter; implP|iter;
  int dir; implP|dir;
  int width; implP|width;
  int height; implP|height;
  int impl_off_ghostData, impl_cnt_ghostData; 
  implP|impl_off_ghostData;
  implP|impl_cnt_ghostData;
  impl_buf+=CK_ALIGN(implP.size(),16);
  /*Unmarshall arrays:*/
  Real_t *ghostData=(Real_t *)(impl_buf+impl_off_ghostData);
  impl_obj->receiveElemGhosts(iter, dir, width, height, ghostData);
}

int CkIndex_Domain::_callmarshall_receiveElemGhosts_marshall9(char* impl_buf, void* impl_obj_void) {
  Domain* impl_obj = static_cast< Domain *>(impl_obj_void);
  /*Unmarshall pup'd fields: int iter, int dir, int width, int height, const Real_t *ghostData*/
  PUP::fromMem implP(impl_buf);
  int iter; implP|iter;
  int dir; implP|dir;
  int width; implP|width;
  int height; implP|height;
  int impl_off_ghostData, impl_cnt_ghostData; 
  implP|impl_off_ghostData;
  implP|impl_cnt_ghostData;
  impl_buf+=CK_ALIGN(implP.size(),16);
  /*Unmarshall arrays:*/
  Real_t *ghostData=(Real_t *)(impl_buf+impl_off_ghostData);
  impl_obj->receiveElemGhosts(iter, dir, width, height, ghostData);
  return implP.size();
}

void CkIndex_Domain::_marshallmessagepup_receiveElemGhosts_marshall9(PUP::er &implDestP,void *impl_msg) {
  CkMarshallMsg *impl_msg_typed=(CkMarshallMsg *)impl_msg;
  char *impl_buf=impl_msg_typed->msgBuf;
  /*Unmarshall pup'd fields: int iter, int dir, int width, int height, const Real_t *ghostData*/
  PUP::fromMem implP(impl_buf);
  int iter; implP|iter;
  int dir; implP|dir;
  int width; implP|width;
  int height; implP|height;
  int impl_off_ghostData, impl_cnt_ghostData; 
  implP|impl_off_ghostData;
  implP|impl_cnt_ghostData;
  impl_buf+=CK_ALIGN(implP.size(),16);
  /*Unmarshall arrays:*/
  Real_t *ghostData=(Real_t *)(impl_buf+impl_off_ghostData);
  if (implDestP.hasComments()) implDestP.comment("iter");
  implDestP|iter;
  if (implDestP.hasComments()) implDestP.comment("dir");
  implDestP|dir;
  if (implDestP.hasComments()) implDestP.comment("width");
  implDestP|width;
  if (implDestP.hasComments()) implDestP.comment("height");
  implDestP|height;
  if (implDestP.hasComments()) implDestP.comment("ghostData");
  implDestP.synchronize(PUP::sync_begin_array);
  { for (int impl_i=0;impl_i*(sizeof(*ghostData))<impl_cnt_ghostData;impl_i++) { 
      implDestP.synchronize(PUP::sync_item);
      implDestP|ghostData[impl_i];
  } } 
  implDestP.synchronize(PUP::sync_end_array);
}
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: void receiveNodalMass(int dir, int width, int height, const Real_t *ghostData);
 */

void CProxy_Domain::receiveNodalMass(int dir, int width, int height, const Real_t *ghostData, const CkEntryOptions *impl_e_opts) 
{
  ckCheck();
  //Marshall: int dir, int width, int height, const Real_t *ghostData
  int impl_off=0;
  int impl_arrstart=0;
  int impl_off_ghostData, impl_cnt_ghostData;
  impl_off_ghostData=impl_off=CK_ALIGN(impl_off,sizeof(Real_t));
  impl_off+=(impl_cnt_ghostData=sizeof(Real_t)*(width*height));
  { //Find the size of the PUP'd data
    PUP::sizer implP;
    implP|dir;
    implP|width;
    implP|height;
    implP|impl_off_ghostData;
    implP|impl_cnt_ghostData;
    impl_arrstart=CK_ALIGN(implP.size(),16);
    impl_off+=impl_arrstart;
  }
  CkMarshallMsg *impl_msg=CkAllocateMarshallMsg(impl_off,impl_e_opts);
  { //Copy over the PUP'd data
    PUP::toMem implP((void *)impl_msg->msgBuf);
    implP|dir;
    implP|width;
    implP|height;
    implP|impl_off_ghostData;
    implP|impl_cnt_ghostData;
  }
  char *impl_buf=impl_msg->msgBuf+impl_arrstart;
  memcpy(impl_buf+impl_off_ghostData,ghostData,impl_cnt_ghostData);
  CkArrayMessage *impl_amsg=(CkArrayMessage *)impl_msg;
  impl_amsg->array_setIfNotThere(CkArray_IfNotThere_buffer);
  ckBroadcast(impl_amsg, CkIndex_Domain::idx_receiveNodalMass_marshall10(),0);
}

// Entry point registration function

int CkIndex_Domain::reg_receiveNodalMass_marshall10() {
  int epidx = CkRegisterEp("receiveNodalMass(int dir, int width, int height, const Real_t *ghostData)",
      _call_receiveNodalMass_marshall10, CkMarshallMsg::__idx, __idx, 0+CK_EP_NOKEEP);
  CkRegisterMarshallUnpackFn(epidx, _callmarshall_receiveNodalMass_marshall10);
  CkRegisterMessagePupFn(epidx, _marshallmessagepup_receiveNodalMass_marshall10);

  return epidx;
}


void CkIndex_Domain::_call_receiveNodalMass_marshall10(void* impl_msg, void* impl_obj_void)
{
  Domain* impl_obj = static_cast<Domain *>(impl_obj_void);
  CkMarshallMsg *impl_msg_typed=(CkMarshallMsg *)impl_msg;
  char *impl_buf=impl_msg_typed->msgBuf;
  /*Unmarshall pup'd fields: int dir, int width, int height, const Real_t *ghostData*/
  PUP::fromMem implP(impl_buf);
  int dir; implP|dir;
  int width; implP|width;
  int height; implP|height;
  int impl_off_ghostData, impl_cnt_ghostData; 
  implP|impl_off_ghostData;
  implP|impl_cnt_ghostData;
  impl_buf+=CK_ALIGN(implP.size(),16);
  /*Unmarshall arrays:*/
  Real_t *ghostData=(Real_t *)(impl_buf+impl_off_ghostData);
  impl_obj->receiveNodalMass(dir, width, height, ghostData);
}

int CkIndex_Domain::_callmarshall_receiveNodalMass_marshall10(char* impl_buf, void* impl_obj_void) {
  Domain* impl_obj = static_cast< Domain *>(impl_obj_void);
  /*Unmarshall pup'd fields: int dir, int width, int height, const Real_t *ghostData*/
  PUP::fromMem implP(impl_buf);
  int dir; implP|dir;
  int width; implP|width;
  int height; implP|height;
  int impl_off_ghostData, impl_cnt_ghostData; 
  implP|impl_off_ghostData;
  implP|impl_cnt_ghostData;
  impl_buf+=CK_ALIGN(implP.size(),16);
  /*Unmarshall arrays:*/
  Real_t *ghostData=(Real_t *)(impl_buf+impl_off_ghostData);
  impl_obj->receiveNodalMass(dir, width, height, ghostData);
  return implP.size();
}

void CkIndex_Domain::_marshallmessagepup_receiveNodalMass_marshall10(PUP::er &implDestP,void *impl_msg) {
  CkMarshallMsg *impl_msg_typed=(CkMarshallMsg *)impl_msg;
  char *impl_buf=impl_msg_typed->msgBuf;
  /*Unmarshall pup'd fields: int dir, int width, int height, const Real_t *ghostData*/
  PUP::fromMem implP(impl_buf);
  int dir; implP|dir;
  int width; implP|width;
  int height; implP|height;
  int impl_off_ghostData, impl_cnt_ghostData; 
  implP|impl_off_ghostData;
  implP|impl_cnt_ghostData;
  impl_buf+=CK_ALIGN(implP.size(),16);
  /*Unmarshall arrays:*/
  Real_t *ghostData=(Real_t *)(impl_buf+impl_off_ghostData);
  if (implDestP.hasComments()) implDestP.comment("dir");
  implDestP|dir;
  if (implDestP.hasComments()) implDestP.comment("width");
  implDestP|width;
  if (implDestP.hasComments()) implDestP.comment("height");
  implDestP|height;
  if (implDestP.hasComments()) implDestP.comment("ghostData");
  implDestP.synchronize(PUP::sync_begin_array);
  { for (int impl_i=0;impl_i*(sizeof(*ghostData))<impl_cnt_ghostData;impl_i++) { 
      implDestP.synchronize(PUP::sync_item);
      implDestP|ghostData[impl_i];
  } } 
  implDestP.synchronize(PUP::sync_end_array);
}
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: void printEnergy(void);
 */

void CProxy_Domain::printEnergy(void) 
{
  ckCheck();
  void *impl_msg = CkAllocSysMsg();
  CkArrayMessage *impl_amsg=(CkArrayMessage *)impl_msg;
  impl_amsg->array_setIfNotThere(CkArray_IfNotThere_buffer);
  ckBroadcast(impl_amsg, CkIndex_Domain::idx_printEnergy_void(),0);
}

// Entry point registration function

int CkIndex_Domain::reg_printEnergy_void() {
  int epidx = CkRegisterEp("printEnergy(void)",
      _call_printEnergy_void, 0, __idx, 0);
  return epidx;
}


void CkIndex_Domain::_call_printEnergy_void(void* impl_msg, void* impl_obj_void)
{
  Domain* impl_obj = static_cast<Domain *>(impl_obj_void);
  CkFreeSysMsg(impl_msg);
  impl_obj->printEnergy();
}
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: void begin_iteration(void);
 */

void CProxy_Domain::begin_iteration(void) 
{
  ckCheck();
  void *impl_msg = CkAllocSysMsg();
  CkArrayMessage *impl_amsg=(CkArrayMessage *)impl_msg;
  impl_amsg->array_setIfNotThere(CkArray_IfNotThere_buffer);
  ckBroadcast(impl_amsg, CkIndex_Domain::idx_begin_iteration_void(),0);
}

// Entry point registration function

int CkIndex_Domain::reg_begin_iteration_void() {
  int epidx = CkRegisterEp("begin_iteration(void)",
      _call_begin_iteration_void, 0, __idx, 0);
  return epidx;
}


void CkIndex_Domain::_call_begin_iteration_void(void* impl_msg, void* impl_obj_void)
{
  Domain* impl_obj = static_cast<Domain *>(impl_obj_void);
  CkFreeSysMsg(impl_msg);
  impl_obj->begin_iteration();
}
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: void doSync(void);
 */

void CProxy_Domain::doSync(void) 
{
  ckCheck();
  void *impl_msg = CkAllocSysMsg();
  CkArrayMessage *impl_amsg=(CkArrayMessage *)impl_msg;
  impl_amsg->array_setIfNotThere(CkArray_IfNotThere_buffer);
  ckBroadcast(impl_amsg, CkIndex_Domain::idx_doSync_void(),0);
}

// Entry point registration function

int CkIndex_Domain::reg_doSync_void() {
  int epidx = CkRegisterEp("doSync(void)",
      _call_doSync_void, 0, __idx, 0);
  return epidx;
}


void CkIndex_Domain::_call_doSync_void(void* impl_msg, void* impl_obj_void)
{
  Domain* impl_obj = static_cast<Domain *>(impl_obj_void);
  CkFreeSysMsg(impl_msg);
  impl_obj->doSync();
}
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: void run1(void);
 */

void CProxy_Domain::run1(void) 
{
  ckCheck();
  void *impl_msg = CkAllocSysMsg();
  CkArrayMessage *impl_amsg=(CkArrayMessage *)impl_msg;
  impl_amsg->array_setIfNotThere(CkArray_IfNotThere_buffer);
  ckBroadcast(impl_amsg, CkIndex_Domain::idx_run1_void(),0);
}

// Entry point registration function

int CkIndex_Domain::reg_run1_void() {
  int epidx = CkRegisterEp("run1(void)",
      _call_run1_void, 0, __idx, 0);
  return epidx;
}


void CkIndex_Domain::_call_run1_void(void* impl_msg, void* impl_obj_void)
{
  Domain* impl_obj = static_cast<Domain *>(impl_obj_void);
  CkFreeSysMsg(impl_msg);
  impl_obj->run1();
}
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: Domain(CkMigrateMessage* impl_msg);
 */

// Entry point registration function

int CkIndex_Domain::reg_Domain_CkMigrateMessage() {
  int epidx = CkRegisterEp("Domain(CkMigrateMessage* impl_msg)",
      _call_Domain_CkMigrateMessage, 0, __idx, 0);
  return epidx;
}


void CkIndex_Domain::_call_Domain_CkMigrateMessage(void* impl_msg, void* impl_obj_void)
{
  Domain* impl_obj = static_cast<Domain *>(impl_obj_void);
  new (impl_obj) Domain((CkMigrateMessage*)impl_msg);
}
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: Domain(void);
 */
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: void startLB(void);
 */

void CProxySection_Domain::startLB(void) 
{
  ckCheck();
  void *impl_msg = CkAllocSysMsg();
  CkArrayMessage *impl_amsg=(CkArrayMessage *)impl_msg;
  impl_amsg->array_setIfNotThere(CkArray_IfNotThere_buffer);
  ckSend(impl_amsg, CkIndex_Domain::idx_startLB_void(),0);
}
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: void beginIteration(void);
 */

void CProxySection_Domain::beginIteration(void) 
{
  ckCheck();
  void *impl_msg = CkAllocSysMsg();
  CkArrayMessage *impl_amsg=(CkArrayMessage *)impl_msg;
  impl_amsg->array_setIfNotThere(CkArray_IfNotThere_buffer);
  ckSend(impl_amsg, CkIndex_Domain::idx_beginIteration_void(),0);
}
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: void resumeNodeIteration(void);
 */

void CProxySection_Domain::resumeNodeIteration(void) 
{
  ckCheck();
  void *impl_msg = CkAllocSysMsg();
  CkArrayMessage *impl_amsg=(CkArrayMessage *)impl_msg;
  impl_amsg->array_setIfNotThere(CkArray_IfNotThere_buffer);
  ckSend(impl_amsg, CkIndex_Domain::idx_resumeNodeIteration_void(),0);
}
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: void resumeElemIteration(void);
 */

void CProxySection_Domain::resumeElemIteration(void) 
{
  ckCheck();
  void *impl_msg = CkAllocSysMsg();
  CkArrayMessage *impl_amsg=(CkArrayMessage *)impl_msg;
  impl_amsg->array_setIfNotThere(CkArray_IfNotThere_buffer);
  ckSend(impl_amsg, CkIndex_Domain::idx_resumeElemIteration_void(),0);
}
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: void sendNodalMass(void);
 */

void CProxySection_Domain::sendNodalMass(void) 
{
  ckCheck();
  void *impl_msg = CkAllocSysMsg();
  CkArrayMessage *impl_amsg=(CkArrayMessage *)impl_msg;
  impl_amsg->array_setIfNotThere(CkArray_IfNotThere_buffer);
  ckSend(impl_amsg, CkIndex_Domain::idx_sendNodalMass_void(),0);
}
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: void ResumeFromSync(void);
 */

void CProxySection_Domain::ResumeFromSync(void) 
{
  ckCheck();
  void *impl_msg = CkAllocSysMsg();
  CkArrayMessage *impl_amsg=(CkArrayMessage *)impl_msg;
  impl_amsg->array_setIfNotThere(CkArray_IfNotThere_buffer);
  ckSend(impl_amsg, CkIndex_Domain::idx_ResumeFromSync_void(),0);
}
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: void receiveNodeGhosts(int iter, int dir, int width, int height, const Real_t *ghostData);
 */

void CProxySection_Domain::receiveNodeGhosts(int iter, int dir, int width, int height, const Real_t *ghostData, const CkEntryOptions *impl_e_opts) 
{
  ckCheck();
  //Marshall: int iter, int dir, int width, int height, const Real_t *ghostData
  int impl_off=0;
  int impl_arrstart=0;
  int impl_off_ghostData, impl_cnt_ghostData;
  impl_off_ghostData=impl_off=CK_ALIGN(impl_off,sizeof(Real_t));
  impl_off+=(impl_cnt_ghostData=sizeof(Real_t)*(width*height*3));
  { //Find the size of the PUP'd data
    PUP::sizer implP;
    implP|iter;
    implP|dir;
    implP|width;
    implP|height;
    implP|impl_off_ghostData;
    implP|impl_cnt_ghostData;
    impl_arrstart=CK_ALIGN(implP.size(),16);
    impl_off+=impl_arrstart;
  }
  CkMarshallMsg *impl_msg=CkAllocateMarshallMsg(impl_off,impl_e_opts);
  { //Copy over the PUP'd data
    PUP::toMem implP((void *)impl_msg->msgBuf);
    implP|iter;
    implP|dir;
    implP|width;
    implP|height;
    implP|impl_off_ghostData;
    implP|impl_cnt_ghostData;
  }
  char *impl_buf=impl_msg->msgBuf+impl_arrstart;
  memcpy(impl_buf+impl_off_ghostData,ghostData,impl_cnt_ghostData);
  CkArrayMessage *impl_amsg=(CkArrayMessage *)impl_msg;
  impl_amsg->array_setIfNotThere(CkArray_IfNotThere_buffer);
  ckSend(impl_amsg, CkIndex_Domain::idx_receiveNodeGhosts_marshall8(),0);
}
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: void receiveElemGhosts(int iter, int dir, int width, int height, const Real_t *ghostData);
 */

void CProxySection_Domain::receiveElemGhosts(int iter, int dir, int width, int height, const Real_t *ghostData, const CkEntryOptions *impl_e_opts) 
{
  ckCheck();
  //Marshall: int iter, int dir, int width, int height, const Real_t *ghostData
  int impl_off=0;
  int impl_arrstart=0;
  int impl_off_ghostData, impl_cnt_ghostData;
  impl_off_ghostData=impl_off=CK_ALIGN(impl_off,sizeof(Real_t));
  impl_off+=(impl_cnt_ghostData=sizeof(Real_t)*(width*height*3));
  { //Find the size of the PUP'd data
    PUP::sizer implP;
    implP|iter;
    implP|dir;
    implP|width;
    implP|height;
    implP|impl_off_ghostData;
    implP|impl_cnt_ghostData;
    impl_arrstart=CK_ALIGN(implP.size(),16);
    impl_off+=impl_arrstart;
  }
  CkMarshallMsg *impl_msg=CkAllocateMarshallMsg(impl_off,impl_e_opts);
  { //Copy over the PUP'd data
    PUP::toMem implP((void *)impl_msg->msgBuf);
    implP|iter;
    implP|dir;
    implP|width;
    implP|height;
    implP|impl_off_ghostData;
    implP|impl_cnt_ghostData;
  }
  char *impl_buf=impl_msg->msgBuf+impl_arrstart;
  memcpy(impl_buf+impl_off_ghostData,ghostData,impl_cnt_ghostData);
  CkArrayMessage *impl_amsg=(CkArrayMessage *)impl_msg;
  impl_amsg->array_setIfNotThere(CkArray_IfNotThere_buffer);
  ckSend(impl_amsg, CkIndex_Domain::idx_receiveElemGhosts_marshall9(),0);
}
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: void receiveNodalMass(int dir, int width, int height, const Real_t *ghostData);
 */

void CProxySection_Domain::receiveNodalMass(int dir, int width, int height, const Real_t *ghostData, const CkEntryOptions *impl_e_opts) 
{
  ckCheck();
  //Marshall: int dir, int width, int height, const Real_t *ghostData
  int impl_off=0;
  int impl_arrstart=0;
  int impl_off_ghostData, impl_cnt_ghostData;
  impl_off_ghostData=impl_off=CK_ALIGN(impl_off,sizeof(Real_t));
  impl_off+=(impl_cnt_ghostData=sizeof(Real_t)*(width*height));
  { //Find the size of the PUP'd data
    PUP::sizer implP;
    implP|dir;
    implP|width;
    implP|height;
    implP|impl_off_ghostData;
    implP|impl_cnt_ghostData;
    impl_arrstart=CK_ALIGN(implP.size(),16);
    impl_off+=impl_arrstart;
  }
  CkMarshallMsg *impl_msg=CkAllocateMarshallMsg(impl_off,impl_e_opts);
  { //Copy over the PUP'd data
    PUP::toMem implP((void *)impl_msg->msgBuf);
    implP|dir;
    implP|width;
    implP|height;
    implP|impl_off_ghostData;
    implP|impl_cnt_ghostData;
  }
  char *impl_buf=impl_msg->msgBuf+impl_arrstart;
  memcpy(impl_buf+impl_off_ghostData,ghostData,impl_cnt_ghostData);
  CkArrayMessage *impl_amsg=(CkArrayMessage *)impl_msg;
  impl_amsg->array_setIfNotThere(CkArray_IfNotThere_buffer);
  ckSend(impl_amsg, CkIndex_Domain::idx_receiveNodalMass_marshall10(),0);
}
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: void printEnergy(void);
 */

void CProxySection_Domain::printEnergy(void) 
{
  ckCheck();
  void *impl_msg = CkAllocSysMsg();
  CkArrayMessage *impl_amsg=(CkArrayMessage *)impl_msg;
  impl_amsg->array_setIfNotThere(CkArray_IfNotThere_buffer);
  ckSend(impl_amsg, CkIndex_Domain::idx_printEnergy_void(),0);
}
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: void begin_iteration(void);
 */

void CProxySection_Domain::begin_iteration(void) 
{
  ckCheck();
  void *impl_msg = CkAllocSysMsg();
  CkArrayMessage *impl_amsg=(CkArrayMessage *)impl_msg;
  impl_amsg->array_setIfNotThere(CkArray_IfNotThere_buffer);
  ckSend(impl_amsg, CkIndex_Domain::idx_begin_iteration_void(),0);
}
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: void doSync(void);
 */

void CProxySection_Domain::doSync(void) 
{
  ckCheck();
  void *impl_msg = CkAllocSysMsg();
  CkArrayMessage *impl_amsg=(CkArrayMessage *)impl_msg;
  impl_amsg->array_setIfNotThere(CkArray_IfNotThere_buffer);
  ckSend(impl_amsg, CkIndex_Domain::idx_doSync_void(),0);
}
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: void run1(void);
 */

void CProxySection_Domain::run1(void) 
{
  ckCheck();
  void *impl_msg = CkAllocSysMsg();
  CkArrayMessage *impl_amsg=(CkArrayMessage *)impl_msg;
  impl_amsg->array_setIfNotThere(CkArray_IfNotThere_buffer);
  ckSend(impl_amsg, CkIndex_Domain::idx_run1_void(),0);
}
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: Domain(CkMigrateMessage* impl_msg);
 */
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
#endif /* CK_TEMPLATES_ONLY */
#ifndef CK_TEMPLATES_ONLY
void CkIndex_Domain::__register(const char *s, size_t size) {
  __idx = CkRegisterChare(s, size, TypeArray);
  CkRegisterBase(__idx, CkIndex_ArrayElement::__idx);
  // REG: Domain(void);
  idx_Domain_void();
  CkRegisterDefaultCtor(__idx, idx_Domain_void());

  // REG: void startLB(void);
  idx_startLB_void();

  // REG: void beginIteration(void);
  idx_beginIteration_void();

  // REG: void resumeNodeIteration(void);
  idx_resumeNodeIteration_void();

  // REG: void resumeElemIteration(void);
  idx_resumeElemIteration_void();

  // REG: void sendNodalMass(void);
  idx_sendNodalMass_void();

  // REG: void ResumeFromSync(void);
  idx_ResumeFromSync_void();

  // REG: void receiveNodeGhosts(int iter, int dir, int width, int height, const Real_t *ghostData);
  idx_receiveNodeGhosts_marshall8();

  // REG: void receiveElemGhosts(int iter, int dir, int width, int height, const Real_t *ghostData);
  idx_receiveElemGhosts_marshall9();

  // REG: void receiveNodalMass(int dir, int width, int height, const Real_t *ghostData);
  idx_receiveNodalMass_marshall10();

  // REG: void printEnergy(void);
  idx_printEnergy_void();

  // REG: void begin_iteration(void);
  idx_begin_iteration_void();

  // REG: void doSync(void);
  idx_doSync_void();

  // REG: void run1(void);
  idx_run1_void();

  // REG: Domain(CkMigrateMessage* impl_msg);
  idx_Domain_CkMigrateMessage();
  CkRegisterMigCtor(__idx, idx_Domain_CkMigrateMessage());

  Domain::__sdag_register(); 
}
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
void Domain::run1() {
    _TRACE_END_EXECUTE(); 
    if (!__cDep.get())
        _sdag_init();
    _slist_0();
    _TRACE_BEGIN_EXECUTE_DETAILED(-1, -1, _dummyEP, CkMyPe(), 0, NULL); 
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
void Domain::run1_end() {
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
void Domain::_slist_0() {
    _atomic_0();
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
void Domain::_slist_0_end() {
    run1_end();
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
void Domain::_atomic_0() {
    _TRACE_BEGIN_EXECUTE_DETAILED(-1, -1, (_sdag_idx_Domain_atomic_0()), CkMyPe(), 0, NULL); 
    





      
    _TRACE_END_EXECUTE(); 
    _slist_0_end();
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
void Domain::_sdag_init() {
    __cDep.reset(new CDep(0,0));
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
void Domain::__sdag_init() {
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
void Domain::__sdag_pup(PUP::er &p) {
    bool hasSDAG = __cDep.get();
    p|hasSDAG;
    if (p.isUnpacking() && hasSDAG) _sdag_init();
    if (hasSDAG) { __cDep->pup(p); }
}
#endif /* CK_TEMPLATES_ONLY */
#ifndef CK_TEMPLATES_ONLY
void Domain::__sdag_register() {
    (void)_sdag_idx_Domain_atomic_0();
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
int Domain::_sdag_idx_Domain_atomic_0() {
  static int epidx = _sdag_reg_Domain_atomic_0();
  return epidx;
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
int Domain::_sdag_reg_Domain_atomic_0() {
  return CkRegisterEp("Domain_atomic_0", NULL, 0, CkIndex_Domain::__idx, 0);
}
#endif /* CK_TEMPLATES_ONLY */



#ifndef CK_TEMPLATES_ONLY
void _registerllCharm(void)
{
  static int _done = 0; if(_done) return; _done = 1;
  _registerPowerLog();

  CkRegisterReadonly("mainProxy","CProxy_Main",sizeof(mainProxy),(void *) &mainProxy,__xlater_roPup_mainProxy);

  CkRegisterReadonly("elemDimX","int",sizeof(elemDimX),(void *) &elemDimX,__xlater_roPup_elemDimX);

  CkRegisterReadonly("elemDimY","int",sizeof(elemDimY),(void *) &elemDimY,__xlater_roPup_elemDimY);

  CkRegisterReadonly("elemDimZ","int",sizeof(elemDimZ),(void *) &elemDimZ,__xlater_roPup_elemDimZ);

  CkRegisterReadonly("blockDimX","int",sizeof(blockDimX),(void *) &blockDimX,__xlater_roPup_blockDimX);

  CkRegisterReadonly("blockDimY","int",sizeof(blockDimY),(void *) &blockDimY,__xlater_roPup_blockDimY);

  CkRegisterReadonly("blockDimZ","int",sizeof(blockDimZ),(void *) &blockDimZ,__xlater_roPup_blockDimZ);

  CkRegisterReadonly("ghostDimX","int",sizeof(ghostDimX),(void *) &ghostDimX,__xlater_roPup_ghostDimX);

  CkRegisterReadonly("ghostDimY","int",sizeof(ghostDimY),(void *) &ghostDimY,__xlater_roPup_ghostDimY);

  CkRegisterReadonly("ghostDimZ","int",sizeof(ghostDimZ),(void *) &ghostDimZ,__xlater_roPup_ghostDimZ);

  CkRegisterReadonly("chareDimX","int",sizeof(chareDimX),(void *) &chareDimX,__xlater_roPup_chareDimX);

  CkRegisterReadonly("chareDimY","int",sizeof(chareDimY),(void *) &chareDimY,__xlater_roPup_chareDimY);

  CkRegisterReadonly("chareDimZ","int",sizeof(chareDimZ),(void *) &chareDimZ,__xlater_roPup_chareDimZ);

  CkRegisterReadonly("charesPerPE","double",sizeof(charesPerPE),(void *) &charesPerPE,__xlater_roPup_charesPerPE);

  CkRegisterReadonly("numElems","int",sizeof(numElems),(void *) &numElems,__xlater_roPup_numElems);

  CkRegisterReadonly("numNodes","int",sizeof(numNodes),(void *) &numNodes,__xlater_roPup_numNodes);

  CkRegisterReadonly("ghostElems","int",sizeof(ghostElems),(void *) &ghostElems,__xlater_roPup_ghostElems);

  CkRegisterReadonly("frontOffset","int",sizeof(frontOffset),(void *) &frontOffset,__xlater_roPup_frontOffset);

  CkRegisterReadonly("backOffset","int",sizeof(backOffset),(void *) &backOffset,__xlater_roPup_backOffset);

  CkRegisterReadonly("rightOffset","int",sizeof(rightOffset),(void *) &rightOffset,__xlater_roPup_rightOffset);

  CkRegisterReadonly("leftOffset","int",sizeof(leftOffset),(void *) &leftOffset,__xlater_roPup_leftOffset);

  CkRegisterReadonly("upOffset","int",sizeof(upOffset),(void *) &upOffset,__xlater_roPup_upOffset);

  CkRegisterReadonly("downOffset","int",sizeof(downOffset),(void *) &downOffset,__xlater_roPup_downOffset);

  CkRegisterReadonly("stopTime","Real_t",sizeof(stopTime),(void *) &stopTime,__xlater_roPup_stopTime);

  CkRegisterReadonly("lbFrequency","int",sizeof(lbFrequency),(void *) &lbFrequency,__xlater_roPup_lbFrequency);

  CkRegisterReadonly("cpFrequency","int",sizeof(cpFrequency),(void *) &cpFrequency,__xlater_roPup_cpFrequency);

  CkRegisterReadonly("maxIterations","int",sizeof(maxIterations),(void *) &maxIterations,__xlater_roPup_maxIterations);

  _registerInitCall(registerMinReal,1);

  _registerInitCall(registerAveTime,1);

/* REG: mainchare Main: Chare{
Main(CkArgMsg* impl_msg);
void averageTimeCheckin(CkReductionMsg* impl_msg);
void initCheckin(CkReductionMsg* impl_msg);
void report(CkReductionMsg* impl_msg);
void afterCkpt(void);
void updateLastT(void);
Main(CkMigrateMessage* impl_msg);
};
*/
  CkIndex_Main::__register("Main", sizeof(Main));

/* REG: array Domain: ArrayElement{
Domain(void);
void startLB(void);
void beginIteration(void);
void resumeNodeIteration(void);
void resumeElemIteration(void);
void sendNodalMass(void);
void ResumeFromSync(void);
void receiveNodeGhosts(int iter, int dir, int width, int height, const Real_t *ghostData);
void receiveElemGhosts(int iter, int dir, int width, int height, const Real_t *ghostData);
void receiveNodalMass(int dir, int width, int height, const Real_t *ghostData);
void printEnergy(void);
void begin_iteration(void);
void doSync(void);
void run1(void);
Domain(CkMigrateMessage* impl_msg);
};
*/
  CkIndex_Domain::__register("Domain", sizeof(Domain));

}
extern "C" void CkRegisterMainModule(void) {
  _registerllCharm();
}
#endif /* CK_TEMPLATES_ONLY */
